# yaml-language-server: $schema=https://json.schemastore.org/github-workflow.json
name: Build Fuzzy Term Package

on:
  pull_request:
    types:
      - opened
      - synchronize
      - closed
    branches:
      - main
    paths:
      - ".github/workflows/build.yml"
      - "completions/**"
      - "conf.d/**"
      - "functions/**"
      - "skel/**"
  workflow_dispatch:
    inputs:
      type:
        description: "Release type"
        required: true
        default: "beta"
        type: choice
        options:
          - "release"
          - "beta"

permissions: {}

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ startsWith(github.ref, 'refs/pull/') }}

jobs:
  build:
    name: Build
    # Skip only when PR is closed without merge
    if: ${{ !(github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged != true) }}
    runs-on: windows-latest
    timeout-minutes: 30
    permissions:
      contents: read
    env:
      TZ: "Asia/Tokyo"
    outputs:
      short_sha: ${{ steps.archive.outputs.short_sha }}
      zip_name: ${{ steps.archive.outputs.zip_name }}
      ansifilter_version: ${{ steps.versions.outputs.ansifilter_version }}
      fish_version: ${{ steps.versions.outputs.fish_version }}
      fzf_version: ${{ steps.versions.outputs.fzf_version }}
      mintty_version: ${{ steps.versions.outputs.mintty_version }}
      rg_version: ${{ steps.versions.outputs.rg_version }}
      tmux_version: ${{ steps.versions.outputs.tmux_version }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup MSYS2
        id: msys2
        uses: msys2/setup-msys2@v2
        with:
          msystem: UCRT64
          location: D:\
          update: true
          install: >-
            base
            coreutils
            curl
            fish
            mingw-w64-ucrt-x86_64-ansifilter
            mingw-w64-ucrt-x86_64-fzf
            mingw-w64-ucrt-x86_64-ripgrep
            mintty
            ncurses
            tmux

      - name: Verify packages installed
        shell: msys2 {0}
        run: |
          echo "=== Installed packages ==="
          pacman -Q tmux fish mingw-w64-ucrt-x86_64-ansifilter mingw-w64-ucrt-x86_64-fzf mingw-w64-ucrt-x86_64-ripgrep mintty

          echo "=== Binary locations ==="
          which tmux fish
          ls -la /ucrt64/bin/ansifilter.exe /ucrt64/bin/fzf.exe /ucrt64/bin/rg.exe

      - name: Fish syntax and lint check
        shell: msys2 {0}
        run: |
          echo "=== Fish syntax check ==="
          error_count=0
          for f in functions/*.fish completions/*.fish conf.d/*.fish; do
            if [ -f "$f" ]; then
              if fish --no-execute "$f" 2>&1; then
                echo "OK: $f"
              else
                echo "FAIL: $f"
                error_count=$((error_count + 1))
              fi
            fi
          done

          echo ""
          echo "=== Fish indent check (formatting) ==="
          for f in functions/*.fish completions/*.fish conf.d/*.fish; do
            if [ -f "$f" ]; then
              if diff -q "$f" <(fish_indent < "$f") > /dev/null 2>&1; then
                echo "OK: $f"
              else
                echo "WARN: $f (formatting differs from fish_indent)"
              fi
            fi
          done

          if [ $error_count -gt 0 ]; then
            echo ""
            echo "ERROR: $error_count file(s) failed syntax check"
            exit 1
          fi

          echo ""
          echo "All syntax checks passed"

      - name: Get package versions
        id: versions
        shell: msys2 {0}
        run: |
          echo "ansifilter_version=$(pacman -Q mingw-w64-ucrt-x86_64-ansifilter | awk '{print $2}')" >> $GITHUB_OUTPUT
          echo "fish_version=$(pacman -Q fish | awk '{print $2}')" >> $GITHUB_OUTPUT
          echo "fzf_version=$(pacman -Q mingw-w64-ucrt-x86_64-fzf | awk '{print $2}')" >> $GITHUB_OUTPUT
          echo "mintty_version=$(pacman -Q mintty | awk '{print $2}')" >> $GITHUB_OUTPUT
          echo "rg_version=$(pacman -Q mingw-w64-ucrt-x86_64-ripgrep | awk '{print $2}')" >> $GITHUB_OUTPUT
          echo "tmux_version=$(pacman -Q tmux | awk '{print $2}')" >> $GITHUB_OUTPUT

      - name: Copy skeleton files
        shell: msys2 {0}
        run: |
          echo "=== Copying skeleton files ==="
          cp -rv skel/. /etc/skel/
          echo "=== Skeleton files installed ==="
          find /etc/skel -type f
          echo ""
          echo "=== fish_plugins content ==="
          cat /etc/skel/.config/fish/fish_plugins

      - name: Create fssh-release file
        shell: msys2 {0}
        run: |
          cat > /etc/fssh-release <<EOF
          BUILD_REPOSITORY="${{ github.server_url }}/${{ github.repository }}"
          BUILD_BASE_REF="${{ github.base_ref || github.ref_name }}"
          BUILD_DATE="$(date +%Y-%m-%dT%H:%M:%S%z)"
          BUILD_ACTION="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          BUILD_SHA="${{ github.sha }}"
          EOF
          sed -i 's/^[[:space:]]*//' /etc/fssh-release

          echo "=== fssh-release content ==="
          cat /etc/fssh-release

      - name: Clean up MSYS2 environment
        shell: msys2 {0}
        run: |
          # Clear package cache to reduce size
          pacman -Scc --noconfirm

          # Remove cache files but keep directory structure
          rm -rf /var/cache/pacman/pkg/*
          rm -rf /var/log/*

          # Ensure required directories exist with placeholder files
          mkdir -p /tmp /dev/shm /dev/mqueue
          touch /tmp/.keep /dev/shm/.keep /dev/mqueue/.keep

          # Verify critical directories
          echo "=== Checking critical directories ==="
          ls -la /etc/skel/ || echo "WARNING: /etc/skel missing!"
          ls -la /tmp/
          ls -la /dev/

          echo "Cleanup complete"

      - name: Create zip archive
        id: archive
        shell: pwsh
        run: |
          $msysRoot = "${{ steps.msys2.outputs.msys2-location }}"
          $shortSha = "${{ github.sha }}".Substring(0, 7)
          $zipName = "fterm-$shortSha.zip"

          # Remove items that shouldn't be in the archive
          Remove-Item -Path "$msysRoot\proc" -Recurse -Force -ErrorAction SilentlyContinue
          Remove-Item -Path "$msysRoot\dev\fd" -Recurse -Force -ErrorAction SilentlyContinue
          Remove-Item -Path "$msysRoot\dev\std*" -Force -ErrorAction SilentlyContinue

          # Remove unused MSYS2 environments (keep only ucrt64)
          $unusedEnvs = @("clang64", "clangarm64", "mingw32", "mingw64", "msys2")
          foreach ($env in $unusedEnvs) {
            # Remove directory
            Remove-Item -Path "$msysRoot\$env" -Recurse -Force -ErrorAction SilentlyContinue
            # Remove launcher files
            Remove-Item -Path "$msysRoot\$env.exe" -Force -ErrorAction SilentlyContinue
            Remove-Item -Path "$msysRoot\$env.ico" -Force -ErrorAction SilentlyContinue
            Remove-Item -Path "$msysRoot\$env.ini" -Force -ErrorAction SilentlyContinue
          }
          Write-Host "Removed unused environments: $($unusedEnvs -join ', ')"

          # Create zip with 7-Zip
          7z a -tzip -mx=5 $zipName "$msysRoot\*"

          $size = (Get-Item $zipName).Length / 1MB
          Write-Host "Archive: $zipName ($([math]::Round($size, 2)) MB)"

          echo "zip_name=$zipName" >> $env:GITHUB_OUTPUT
          echo "short_sha=$shortSha" >> $env:GITHUB_OUTPUT

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: fterm-${{ steps.archive.outputs.short_sha }}
          path: ${{ steps.archive.outputs.zip_name }}
          retention-days: 7

  release:
    name: Create Release
    needs: build
    if: ${{ always() && needs.build.result == 'success' && (github.event.pull_request.merged == true || inputs.type != '') }}
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: write
    env:
      TZ: "Asia/Tokyo"
    outputs:
      new_tag: ${{ steps.new_tag.outputs.new_tag }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate new tag
        id: new_tag
        run: |
          set -euo pipefail

          TODAY=$(date +'%y.%m.%d')
          YEAR_MONTH=$(date +'%y.%m')
          echo "Today's date: ${TODAY}"
          echo "Year-Month: ${YEAR_MONTH}"

          RELEASE_TYPE="${{ inputs.type }}"
          if [ "${{ github.event.pull_request.merged }}" = "true" ]; then
            RELEASE_TYPE="beta"
          fi

          if [ "${RELEASE_TYPE}" = "release" ]; then
            MATCHED_TAGS=$(git tag --sort=creatordate | grep -E "^v[0-9]{2}\.[0-9]{2}\.[0-9]{2}\.[0-9]{2}$" || true)
            echo "Matched release tags:"
            echo "${MATCHED_TAGS}"

            LATEST_TAG=$(echo "${MATCHED_TAGS}" | grep "^v${TODAY}\." | tail -n 1 || true)
            echo "Latest release tag for today: ${LATEST_TAG}"

            if [ "${LATEST_TAG}" = "" ]; then
              NEW_TAG="v${TODAY}.01"
            else
              LAST_NUM=$(echo "${LATEST_TAG}" | cut -d '.' -f 4)
              NEW_NUM=$(printf "%02d" $((10#${LAST_NUM} + 1)))
              NEW_TAG="v${TODAY}.${NEW_NUM}"
            fi
          else
            ALL_TAGS=$(git tag --sort=-version:refname)
            LATEST_RELEASE=$(echo "${ALL_TAGS}" | grep -E "^v[0-9]{2}\.[0-9]{2}\.[0-9]{2}\.[0-9]{2}$" | head -n 1 || true)
            LATEST_BETA=$(echo "${ALL_TAGS}" | grep -E "^v[0-9]{2}\.[0-9]{2}\.00-beta[0-9]+$" | head -n 1 || true)

            echo "Latest release: ${LATEST_RELEASE}"
            echo "Latest beta: ${LATEST_BETA}"

            if [ "${LATEST_RELEASE}" != "" ]; then
              TAGS_AFTER_RELEASE=$(git tag --sort=creatordate | sed -n "/^${LATEST_RELEASE}$/,\$p" | tail -n +2)
              echo "Tags after latest release:"
              echo "${TAGS_AFTER_RELEASE}"

              NON_BETA_COUNT=$(echo "${TAGS_AFTER_RELEASE}" | grep -v -E "^v[0-9]{2}\.[0-9]{2}\.00-beta[0-9]+$" | grep -c . || true)

              if [ "${NON_BETA_COUNT}" = "0" ] && [ "${LATEST_BETA}" != "" ]; then
                BETA_BASE=$(echo "${LATEST_BETA}" | cut -d '-' -f 1)
                BETA_NUM=$(echo "${LATEST_BETA}" | cut -d '-' -f 2 | sed 's/beta//g')
                NEW_TAG="${BETA_BASE}-beta$((BETA_NUM + 1))"
                echo "All tags after release are beta, incrementing: ${LATEST_BETA} -> ${NEW_TAG}"
              else
                NEW_TAG="v${YEAR_MONTH}.00-beta1"
                echo "Creating new beta for this month: ${NEW_TAG}"
              fi
            else
              if [ "${LATEST_BETA}" != "" ]; then
                BETA_BASE=$(echo "${LATEST_BETA}" | cut -d '-' -f 1)
                BETA_NUM=$(echo "${LATEST_BETA}" | cut -d '-' -f 2 | sed 's/beta//g')
                NEW_TAG="${BETA_BASE}-beta$((BETA_NUM + 1))"
                echo "No release exists, incrementing beta: ${LATEST_BETA} -> ${NEW_TAG}"
              else
                NEW_TAG="v${YEAR_MONTH}.00-beta1"
                echo "No tags exist, creating first beta: ${NEW_TAG}"
              fi
            fi
          fi
          echo "New tag: ${NEW_TAG}"
          echo "new_tag=${NEW_TAG}" >> $GITHUB_OUTPUT

      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: fterm-${{ needs.build.outputs.short_sha }}

      - name: Update fssh-release and rename artifact
        id: release_zip
        run: |
          NEW_TAG="${{ steps.new_tag.outputs.new_tag }}"
          OLD_ZIP="${{ needs.build.outputs.zip_name }}"
          NEW_ZIP="fterm-${NEW_TAG}.zip"

          # Extract, update fssh-release, re-zip
          mkdir -p fterm-temp
          unzip -q "$OLD_ZIP" -d fterm-temp

          # Add BUILD_TAG to fssh-release
          echo "BUILD_TAG=\"${NEW_TAG}\"" >> fterm-temp/etc/fssh-release
          echo "=== Updated fssh-release ==="
          cat fterm-temp/etc/fssh-release

          # Re-create zip with new name
          cd fterm-temp
          zip -rq "../${NEW_ZIP}" .
          cd ..
          rm -rf fterm-temp "$OLD_ZIP"

          echo "zip_name=$NEW_ZIP" >> $GITHUB_OUTPUT
          echo "Created: $NEW_ZIP"

      - name: Get latest release tag
        id: latest_release
        run: |
          LATEST_TAG=$(git tag --sort=-version:refname | grep -E "^v[0-9]{2}\.[0-9]{2}\.[0-9]{2}\.[0-9]{2}$" | head -n1 || echo "")
          echo "latest_tag=${LATEST_TAG}" >> $GITHUB_OUTPUT
          echo "Latest release tag: ${LATEST_TAG}"

      - name: Cleanup old beta releases
        if: ${{ github.event.pull_request.merged == true || inputs.type == 'beta' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const releases = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100,
            });

            const newTag = "${{ steps.new_tag.outputs.new_tag }}";
            const baseVersion = newTag.split('-')[0];

            console.log('New tag: ' + newTag);
            console.log('Base version: ' + baseVersion);

            for (const release of releases.data) {
              if (release.prerelease &&
                  release.tag_name.startsWith(baseVersion + '-beta') &&
                  release.tag_name !== newTag) {
                console.log('Deleting old beta release: ' + release.tag_name);
                await github.rest.repos.deleteRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: release.id,
                });
                try {
                  await github.rest.git.deleteRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: 'tags/' + release.tag_name,
                  });
                  console.log('Deleted tag: ' + release.tag_name);
                } catch (error) {
                  console.log('Could not delete tag: ' + release.tag_name);
                }
              }
            }

      - name: Create Release
        if: ${{ inputs.type == 'release' }}
        uses: softprops/action-gh-release@v2
        with:
          name: ${{ steps.new_tag.outputs.new_tag }}
          tag_name: ${{ steps.new_tag.outputs.new_tag }}
          files: ${{ steps.release_zip.outputs.zip_name }}
          generate_release_notes: true
          draft: false
          prerelease: false
          make_latest: true
          body: |
            ## Fuzzy Term Package

            Portable MSYS2 environment with **pacman support**.

            ### Pre-installed Tools

            | Tool       | Version                                          |
            |------------|--------------------------------------------------|
            | mintty     | ${{ needs.build.outputs.mintty_version }}        |
            | fish       | ${{ needs.build.outputs.fish_version }}          |
            |            |                                                  |
            | ansifilter | ${{ needs.build.outputs.ansifilter_version }}    |
            | fzf        | ${{ needs.build.outputs.fzf_version }}           |
            | ripgrep    | ${{ needs.build.outputs.rg_version }}            |
            | tmux       | ${{ needs.build.outputs.tmux_version }}          |

            ### Quick Start

            1. Extract `fterm.zip` to desired location (e.g., `C:\fterm`)
            2. Run `ucrt64.exe` or `msys2_shell.cmd -ucrt64` to open terminal
            3. Use `pacman -S <package>` to install additional packages

            Built with MSYS2 UCRT64 environment.
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create Beta Release
        if: ${{ github.event.pull_request.merged == true || inputs.type == 'beta' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const newTag = "${{ steps.new_tag.outputs.new_tag }}";
            const latestTag = "${{ steps.latest_release.outputs.latest_tag }}";
            const zipName = "${{ steps.release_zip.outputs.zip_name }}";

            const releaseParams = {
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: newTag,
              name: newTag,
              draft: false,
              prerelease: true,
              make_latest: 'false',
              generate_release_notes: true,
              body: `## Fuzzy Term Package (Beta)

            Portable MSYS2 environment with **pacman support**.

            ### Pre-installed Tools

            | Tool       | Version |
            |------------|---------|
            | mintty     | ${{ needs.build.outputs.mintty_version }} |
            | fish       | ${{ needs.build.outputs.fish_version }} |
            | ansifilter | ${{ needs.build.outputs.ansifilter_version }} |
            | fzf        | ${{ needs.build.outputs.fzf_version }} |
            | ripgrep    | ${{ needs.build.outputs.rg_version }} |
            | tmux       | ${{ needs.build.outputs.tmux_version }} |

            Built with MSYS2 UCRT64 environment.`,
            };

            if (latestTag) {
              releaseParams.previous_tag_name = latestTag;
            }

            const release = await github.rest.repos.createRelease(releaseParams);
            console.log('Created beta release: ' + release.data.html_url);

            // Upload asset
            const zipContent = fs.readFileSync(zipName);
            await github.rest.repos.uploadReleaseAsset({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: release.data.id,
              name: zipName,
              data: zipContent,
            });
            console.log('Uploaded asset: ' + zipName);
